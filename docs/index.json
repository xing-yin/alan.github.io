[{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/alan.github.io/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/alan.github.io/basic-markdown-syntax/"},{"categories":["documentation"],"content":"我们可能经常听到“架构模式”（architectural pattern）这个词，这到底是什么意思？其实所谓的架构模式，就是设计一个程序结构的学问，属于编程方法论的范畴。 这么说有些抽象，我们今天讨论的 MVC 就是一种架构模式，接下来，在正式介绍 Spring MVC 之前先有个直观的认识，我们一起来了解一下 MVC 模式和其发展历史，毕竟站在更高的角度可以帮助我们更好地了解它的整体设计的缘由。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:0:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"什么是 MVC ? MVC 是 Mode(模型)、View(视图)、Controller(控制) 三个单词的缩写，它们的作用大致如下： 组成 作用 View 最上层，即面向终端用户的视图层。用于给用户提供展示和操作的页面。 Controller 中间层，负责根据视图层的输入，选择对应的“数据层”数据，对其进行操作，产生最终数据。 Mode 最底层，即核心的“数据层”，程序需要操作的数据。 这三层相互独立又是紧密联系，每一层内部的变化不影响其他层，很好地体现了软件设计中“解耦”的思想。其中每一层都对外提供接口（Interface），供上面一层调用。通过这种优雅的设计，实现了模块化，修改视图展示或者变更数据都不用修改其他层，极大地方便了维护和升级。 为了方便理解，我们用一个简易计算器为例进行类比。在计算器中，外部的那些按钮和最上面的显示条，相当于\"视图层\"，那些需要运算的数字就是\"数据层\"，执行加减乘除的运算步骤相当于\"控制层\"。每一层执行不同的功能，整个结构清楚明了。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:1:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"MVC 波澜壮阔的“前世今生” 说到 MVC 模式，其实最早是由 Trygve Reenskaug 在1978年提出的一种软件架构，其目的是实现一种动态的程序设计，简化后续对程序的修改和扩展，使得程序实现部分复用成为可能，同时程序结构更加直观。 [idea] 可见，程序的可复用性和可扩展性一直以来都是历代优秀程序员们对于代码的“追求”。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:2:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"时代1：Model1 模式的出现，让“史前”的混沌世界出现黎明前的曙光 Model1 模式其实十分简单，它使用 JSP 页面和 JavaBean 相结合的方式。 JSP 页面负责接收客户端请求， JavaBean 负责业务逻辑处理、数据库操作和返回页面。 那为什么 Model1 后来从江湖上“销声匿迹”了呢？ Model1 架构简单，适合小项目开发。然而，JSP 的职责不单一，职责过重，不方便维护，这也是为什么诞生后逐渐“退隐江湖”。 [idea]这个架构设计违背了软件设计的**“职责单一”**原则。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:3:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"时代2：Model2（MVC）模式出现，刀耕火种的原始时代迈入了石器时代 上面我们提到，Model1 虽然实现了一定程度的解耦，但 JSP 页面既要负责页面控制，又要负责逻辑处理，导致职责不单一。因此，Model2 应运而生，使得各部分各司其职，职责单一。 Model2 就是基于 MVC 模式架构，具体如下： Controller：负责用户交互（Servlet） Model：负责数据逻辑处理（JavaBeans） View：负责数据显示（JSP） Model2 模式有什么优缺点？ 优点：职责清晰，较适合于大型项目 缺点：分层较多，不适合小型项目开发 那 Model1 和 Model2 有什么区别？ Model2 在 Model1 的基础上分离了控制，将 JSP 中的逻辑操作部分分离出来（放在 controller 中），这样做既让 JSP 的职责变得单一，又更有利于分工开发，耦合度降低。因此，对于复杂的 Web 应用开发，更适合使用 Model2，而对于小型应用，使用 Model1 比较简单直接。 [idea]可见，软件开发中一个重要的解耦的思想就是“分层，当已有的架构不满足“高内聚，低耦合”时，再抽象出新的分层就能极大的解决这类问题。像现代计算机体系也是在分层中逐渐迭代演进，逐步发展出今天庞大复杂的体系。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:4:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"时代3：Struts1 匆匆登上历史舞台，又快速落幕 为什么会诞生 Struts1？ Struts1 出现的目的是为了帮助开发者减少运用 MVC 模型开发 Web 应用的时间。因为使用 Struts1可以提高系统的维护和开发效率，我们只需要配置和编码实现Action 和 ActionForm 就可以了。 Struts1 组成部分 为了让你更清楚地看到 Servlet 和 Struts1的区别，接下来我们一起来看下它们的执行过程。 Servlet 的执行过程 使用Servlet， 需要每个页面都设置一个 Servlet 类来处理请求和响应，然后再获取用户提交的数据并把数据与持久化类对应起来。再做判断，决定跳转，再让JSP显示。 Struts1 的执行过程 使用 Struts1时，通过运行时（runtime）初始化ActionServlet，再把所有持久化类的各个属性设为null。当有请求来时，通过name属性找到form-beans中form-bean的name属性，得到ActionForm的包名类名。然后实例化form，把用户数据提交给它，调用form的validate 方法验证。ActionErrors返回null表示验证通过，否则失败返回。验证通过会根据请求的Action类型实例化Action，执行Action的execute方法。根据传进来的ActionForm持久化对象可以取到传进来的数据，这个数据可以先和数据库中的数据交互，再决定跳转。 换句话说，也就是 Struts1封装了request.getParameter()，再把数据传给JavaBean持久化类。另外，Struts1弥补了JPS标签的不足，为开发提供了便利。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:5:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"时代4：Struts2 野心勃勃却“创业未半而中道崩殂” ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:6:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"Struts2 诞生背景 Struts2 和 Struts1的差别巨大，Struts2以 WebWork 为核心，采用拦截器的机制来处理用户的请求，这样的设计使得控制器的业务逻辑与Servlet API完全脱离。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:6:1","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"Struts1 与Struts2 有什么区别？ 我们主要从Action类、线程模式、Servlet依赖、捕获输入、表达式语言等五个方面来进行比较。 比较项 Struts1 Struts2 Action类 Action类继承一个抽象基类 Action类可以实现一个Action接口，也可以实现其他接口 线程模式 单例设计模式且是必须是线程安全，因为仅有一个Action的实例处理所有请求 每一个请求产生一个实例，因此没有线程安全问题 Servlet依赖 依赖于Servlet API，因为当一个Action被调用时HttpservletRequest和HttpServletResponse被传递给execute方法 不依赖于容器，允许Action脱离容器单独被测试 捕获输入 使用ActionForm对象捕获输入，所有的ActionForm必须继承一个基类 直接使用Action属性作为输入属性 表达式语言 整合了JSTL El表达式 不仅可以使用JSTL，也支持ognl表达式语言 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:6:2","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"为什么 Struts2“中道崩殂”？ 随着历史的车轮滚滚向前，曾经风靡一时的 Struts2 最终被 Spring MVC所取代，最主要是因为 Struts2 的安全问题异常严峻，Struts2 的安全漏洞，让不少公司吃尽了苦头，慢慢磨掉了用户的信心。 [idea]做产品一定要为用户考虑，有用户意识，否则，曾经哪怕光芒万丈，也只是过往云烟。 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:6:3","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"时代5：迈入 Spring MVC 如日中天的时代 SpringMVC 原理图 ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:7:0","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":["documentation"],"content":"Spring MVC和 Struts2 有什么区别？ 区别点 Spring MVC Struts2 入口不同 servlet filter 生命周期不同 MVC Controller是单例，所以效率更高，但不能用成员变量获取参数 Struts2 Action 是多例，所以效率比较低，可以用成员变量获取参数 参考链接： [1]https://siteson.github.io/post/history-of-mvc-mode/ [2]http://www.ruanyifeng.com/blog/2007/11/mvc.html ","date":"2021-03-12","objectID":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/:7:1","tags":["content","Markdown"],"title":"Spring MVC 系列之 MVC 模式的“前世今生”","uri":"/alan.github.io/1-mvc-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"},{"categories":null,"content":"关于 AlanYin 大家好，我是尹星，英文名 Alan Yin ，互联网行业程序员，一个喜欢编程、阅读、研究投资的软件工程师。 很幸运出生在这个信息时代，也很幸运选中了自己喜欢的事，赶上这个好的时代，我要做的就是追求持续地成长，与时俱进，stay hungry stay foolish。 我将持续践行长期主义、价值创造，探索编程、阅读、投资的广袤世界，做时间的朋友。 ","date":"2016-06-09","objectID":"/alan.github.io/about/:0:0","tags":null,"title":"","uri":"/alan.github.io/about/"}]